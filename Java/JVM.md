## JVM



### HotSpot虚拟机

> ##### 对象内存布局分为：
>
> > - 对象头
> > - 实例数据
> > - 对齐填充8字节对齐
>
> ##### 对象创建过程
>
> > 类加载检查
> >
> > > JVM解析.class文件时，若遇到一条new指令，首先会去检查常量池中是否有这个类的符号引用，并检查这个符号所代表的类是否以已经被加载、解析和初始化过。如果没有，那么必须执行相应的类加载过程。
> >
> > 为新生对象分配内存
> >
> > > 对象所需的内存的大小在类加载完成后便可以确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中内存有两种方式：
> > >
> > > - 指针碰撞 ： 堆中内存绝对规整，复制算法和标记整理法。
> > > - 空闲列表：内存不规整，如标记清楚法
>
> ##### 对象访问方法：(HotSpot采用直接访问)
>
> > 句柄访问：堆中”句柄池“，句柄包含了对象实例数据（堆中的实例池）与类型数据（方法区）各自的具体地址信息。
> >
> > 直接访问：引用类型的变量直接存放对象的地址，但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址



### 包含

> 线程共享：方法区、堆   
>
> 线程独有：本地方法栈、虚拟机栈、程序计数器
>
> 虚拟机栈中每个方法分配一个栈帧，包含：局部变量表、操作数栈、动态链接和出口信息



### 类的加载过程(加载、链接、初始化)

> 类加载的三种方式：
>
> > 1 命令行启动应用时候由JVM初始化加载
> >
> > 2 通过Class.forName()方法动态加载，默认执行初始化块
> >
> > 3 通过ClassLoader.loadClass()方法动态加载，不会执行初始化块，如果指定loader，不执行静态块
>
> #### 加载 (Loading) ：
>
> 通过类的全限定名(包名+类名)，获取该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构转化为方法区运行时的数据结构，在内存中生成`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口：`加载二进制数据到内存` —> `映射成jvm能识别的结构` —> `在内存中生成class文件`。
>
> 
>
> #### 链接 (Linking) :
>
> 验证(检查class文件类型是否符合虚拟机标准)
>
> 准备(静态字段分配内存，并设置默认的初始值，一般为0/null，final类型在编译时就已经分配)
>
> 解析(符号引用转化为直接引用)(非必须)
>
> 
>
> #### 初始化 (Intialization) ：
>
> 为类的静态变量赋予正确的初始值，JVM负责对类进行初始化。
>
> > - 声明类变量是指定初始值
> > - 使用静态代码块为类变量指定初始值
>
> 若未加载需要先加载
>
> 执行类的构造器方法init()的过程
>
> 不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。
>
> 初始化顺序：
>
> 1. 父类（静态变量、静态语句块）
> 2. 子类（静态变量、静态语句块）
> 3. 父类（实例变量、普通语句块）
> 4. 父类（构造函数）
> 5. 子类（实例变量、普通语句块）
> 6. 子类（构造函数
>
> 
>
> > 五种常见的主动引用：
> >
> > - new 、putstatic 、getstatic 、invokestatic 字节码指令。 
> > - 反射调用。
> > - 初始化该类时需要先初始化其父类。
> > - 访问某个类或者接口的静态变量，或者对该静态变量赋值
> > - 虚拟机启动时，用于需要指定一个包含main()方法的主类、虚拟机会先初始化这个主类。
> > - 使用 JDK1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle 实例最后解析为 REF_getstatic/putstatic/invokestatic 的方法句柄，并且这个方法句柄所对应的类还没有初始化，需要先触发其初始化。
> >
> > 三种被动引用(类不会被初始化)：
> >
> > - 调用父类的类变量
> > - 数组类的初始化
> > - 类静态常量调用public static final
>
> 另外还包括：使用(非必须)和卸载过程。
>
> 三种加载器:
>
> > Bootstrap ClassLoader：<JAVA_HOME>/lib。(c/c++)
> >
> > Extension ClassLoader：<JAVA_HOME>/lib/ext。
> >
> > Application ClassLoader：负责加载用户类路径(classpath)上指定的库。
> >
> > Custom ClassLoader 此外还有用户定义的类加载器。
> >
> > 关系：向上委托



### 双亲委派机制

> 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。------------------系统类防止内存中出现多份同样的字节码
>
> 怎么打破：自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法。





## JVM内存结构

> 方法区：**它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**
>
> 常量池：
>
> > class文件常量池
> >
> > 运行时常量池
> >
> > 全局字符串常量池
> >
> > 基本包装类型包装类对象常量池

 

