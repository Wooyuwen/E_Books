# Java__BaseConcepts



#### java的加载和运行

> 编译：`.java`文件->多个 `.class`文件（字节码文件）[常量池？？静态常量池]
>
> 运行：java.exe在DOS窗口使用
>
> - 启动JVM
> - JVM启动类装载器`ClassLoader`
> - `ClassLoader`会去硬盘上搜索`.class`文件
> - JVM将字节码文件 **解释** 成二进制文件并运行。
>
> `classpath`：能让ClassLoader去指定路径下载字节码文件，在用户环境变量中设置



#### 注释 好的开发习惯：多写注释

> 只生成在源文件中，不存在于class文件中

> **单行注释** ：`//`
>
> **多行注释**: `/* \n\n\n\n   */`
>
> **javadoc多行注释**:`/** \n*\n*\n*\n*\n */`：会被工具解析提取并生成文档



#### 标识符、关键字、字面值（数据）

> 驼峰命名法
>
> 标识符只能由：`数字`   `字母` `下划线` `$` 组成
>
> 字面值：整数型、浮点型、布尔型、字符串型、字符型
>
> #### 修饰符关键字
>
> > ##### `final`: （类，方法，变量）
> >
> > - 类  ：不能继承，类中的成员变量可以设计为final，final中的成员方法会被隐式指定为final方法。
> > - 方法：不能被重写，一个类的private方法会被隐式的指定为final方法。
> > - 成员变量：必须要附初始值（`直接赋值` `全部在构造方法中赋值`），只能初始化一次。**如果修饰的是引用类型，则说明引用的地址的值不能修改，但是引用的对象的值可变**。
>
> > ###### `static`：（方法、变量）
> >
> > - 变量（**类变量**）：被所有的对象所共享，在内存中只有一个副本，当且仅当在类初次加载时会被初始化。
> >
> > - 代码块：优化程序性能，在**类初次被加载**时，会按照static块的顺序来执行每个static块，并且执行一次，因此很多时候将只需进行一次的初始化操作放在static代码块中进行。static代码块能出现在类中任何地方。
> >
> >   ```java
> >   static{
> >       System.out.println("test static");
> >   }
> >   ```
> >
> >   
> >
> > - 静态变量并没有像c++的作用域，作用域的限制只能通过private/public/protected来修饰。
> >
> > - **静态方法和静态变量都可以通过对象访问。**
>
> > **`synchronized`**:（**方法**）
> >
> > - 同一时间只能被一个线程访问，可以搭配四个访问修饰符使用。
>
> > **`volatile`**：（**成员变量**）
> >
> > - 所修饰的成员变量每次被线程访问时，都强制从共享内存中重新读取该成员变量的值；
> > - 当成员变化时，会强制线程将变化后的值写回内存。
>
> > ###### **` protected`**:
> >
> > - 和private一样不能修饰类，同一包内所有类都可以访问，但是不同包只能通过继承，而且只能调用继承的方法，而不能使用父类实例的`protected`方法。
> >
> > 访问控制：
> >
> > - 父类方法声明为public，子类public
> > - 父类protected方法，子类public 或protected
> > - 父类private方法，子类.................子类没有XD





####  变量、数据类型、精度损失

> `boolean `
>
> `byte 8`
>
> `char 16` :字符编码，`a`-97 `A`-75 `0`-48
>
> `short 16`
>
> `int 32`
>
> `float 32`
>
> `long 64`
>
> `double 64`

> ```java
> byte b1=(byte)128;//-128
> ```
>
> 计算机中的数据都是由补码形式存储的
>
> 整数字面值没有超出byte,short,char的取值范围时可以直接复制该字面值，方便程序员的编程



#### 三元运算符

> 布尔表达式?表达式1：表达式2



***



####  运行时内存分析

> 共用：
>
> > `堆`:存放对象的实例和数组，虚拟机管理的最大的一块内存
> >
> > `方法区`;放置已经被虚拟机加载的类信息，常量，静态变量，编译器编译的代码，理论上没有内存限制
>
> 私有：
>
> > - `程序计数器` 存放当前线程执行字节码的行号
> >
> > - `虚拟机栈` 存放线程执行所需要的变量，对象的引用，方法出口信息，动态链接等信息
> >
> > - `本地方法栈`和虚拟机栈类似，区别：`JNI` `（Java Native Interface）`和本地C代码交互的API
> >
> >   
> >   
> >   `native`:用作java和其他语言进行协同作用，通知操作系统，该函数由操作系统实现
>
> java完全采用动态内存分配方式，每创建新对象都使用new关键字来构建此对象的动态实例。


#### 重载

>- 代码美观
>
>- 方便记忆



****





## 面向对象（封装、继承、多态）


> - `this `
>
>   > 关键字指向当前对象实例，存于堆中该实例所在内存中
>   >
>   > 存储的为该实例的地址
>   >
>   > 可以由实例方法和构造方法调用，不能被静态方法调用
>   >
>   > 主要用来区分实例变量和局部变量
>
> - `静态方法`（static）
>
>   > - 只能调用静态方法和静态变量
>   >
>   > - 静态方法可以通过类名直接调用或者通过类的实例对象去调用
>
> - `继承` `extends`
>
>   > - 代码复用
>   >
>   > - **构造方法无法继承，私有的数据无法直接访问，调用父类的方法访问**
>   >
>   > - 默认继承Object类
>   >
>   > - 只允许单继承
>   >
>   > - 子类会自动调用父类无参数的构造方法，带参数的构造方法需要用关键字super显式调用
>   >
>   >   若父类没有默认构造函数，则必须显式调用父类带参数构造函数。
>   >
>   >   - 构造函数执行顺序：先父类，后子类
>   >
>   >   - 类内部的构造顺序：static类的引用= new ...，先构造，只做一次；类的引用=new ...，次之，每次构造都做一次，如果声明时没有加"=new ..."仅神明，不构造；再执行构造函数。



#### Java 静态分派和动态分派

> 函数调用在class文件中存储的是符号引用
>
> `类加载`期或者`运行`期确定目标方法的直接调用
>
> **解析**
>
> > 所有方法调用中的目标方法在class文件中都是常量池中的引用，
> >
> > - 在`类加载`的`解析`阶段，会将其中的一部分符号引用转化为直接引用。  前提：方法在程序真正执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可改变的，在编译期间就确定下来，这类方法的调用成为`解析`    这类 **非虚方法**有：`静态方法`、`私有方法`、`实例构造器`、`父类方法`。
> >
> >   与之相反的是虚方法(final方法除外)



#### Java抽象类和抽象方法

> - 抽象类不能被实例化
> - 抽象类中不一定含有抽象方法，但是抽象方法一定属于抽象类
> - 抽象类中的抽象方法只是声明，不包含方法体
> - 构造方法和类方法（用static修饰的方法）不能声明为抽象方法



#### 异常处理

> 



#### 创建的对象存储到了什么地方

> - 寄存器：最快的存储区，位于处理器的内部，但是数量有限
>
> - 堆栈：位于通用RAM（随机访问存储器），常存储对象的引用；堆栈指针的上下移动可以实现内存的分配和释放。
>
>   > `hints:`创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期
>
> - 堆：通用的内存池，用于存放所有的对象，常用操作符为`new`关键字。
>
> - 常量存储：通常直接存放在程序代码内部，比较安全，永远不会改变。
>
> - 非RAM存储：如果数据完全存活于程序之外，不受程序的任何控制，在程序没有运行时也可以存在：`持久化对象` `流对象`。在流对象中，对象转化成字节流，通常被发送给另一台机器。在持久化对象中，对象被放在磁盘上，因此，即使程序终止，他们仍能保持自己的状态，这种存储方式的技巧在于：将对象转化为可以存放在其他媒介上的事物，在需要时，可以恢复成常规的、基于RAM的对象。JAVA提供了对轻量级持久化的支持。



#### java中的数组

> 创建一个数组对象时，初始化为null，即还没有指向某个对象。



#### 内部类

> **`普通内部类`**:
>
> > - 内部类可使用外部类的变量和方法
> > - 外部类可以创建内部类实例
> > - 作用域关键字用法相同
> > - 需要外部类**实例**创建内部类对象 
> > - `不能定义静态变量、能定义常量`
>
> **`静态内部类`**(用static修饰)
>
> > - 只能访问外部类的static方法和变量
> > - 可以直接创建，不需要外部类应用
>
> **`局部内部类`**
>
> > - 定义在程序块中，只在块内有效；块外不能创建和引用
> > - 只能用abstract和final修饰
> > - 可以访问外部类成员
> > - 可访问块中的final局部变量
>
> **`匿名内部类`**
>
> > - 没有引用名的对象
> >
> > ```java
> > new Test().show();
> > ```
> >
> > - 匿名类：继承父类或者实现接口
> >
> >   ```java
> >   new Test(){
> >           @override show()
> >   }.show();
> >   ```
> >



### 多态

> ##### 引用的类型转换
>
> - 子类可以自动视为父类
> - 父类变成子类需要显示的类型转换（小转大不变，大转小要变）
> - 除了继承关系，否则不允许类型转换
>
> 里氏替换法则：
>
> - 子类对象能够替换其父类对象被使用
> - 子类的引用可以直接赋值给父类的引用



#### 抽象类

> 抽象类必须被继承实现：可以用来定义某些共性



 #### 接口

> 把需要实现的方法和共有常量定义在接口里：
>
> - 接口的变量默认为`public final static`（常量）
> - 接口的方法默认为`public abstract`
>
> 借口的定义：`default`和`public`两种类型：
>
> > public的接口，必须定义在同名文件里
>
> 可以有内部接口、没有局部接口、可以用匿名类实现接口
>
> java 1.8允许接口实现方法 `default`
>
> 接口可以extends其他接口，一个类可以实现多个接口
>
> 接口的私有方法：方便接口内复用



#### Java泛型类

> 类的泛型（模板类）
>
> - 把用到的数据类型抽象为泛型
> - 在类创建的时候才指定类型
> - 此模板可以接受合适类型的对象
>
> 目的：安全，编译期能进行类型检查
>
> 模板可为类：可限定类型必须是某个指定类型或者子类，或是实现了某个接口，够用extends
>
> **静态方法不能使用类的泛型**（泛型类作为参数）



#### Java泛型接口、泛型方法

> 静态方法支持泛型方法

**没有泛型对象数组**

JAVA泛型只在编译时处理



常用Java泛型类:

ArrayList 视为变长数组



