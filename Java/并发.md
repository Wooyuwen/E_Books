# 并发



## 一、使用线程

> - 实现Runnable接口
>
>   ```java
>   public class MyRunnable implements Runnable {
>     @Override
>     public void run() {
>         // ...
>     }
>   }
>   public static void main(String[] args) {
>       MyRunnable instance = new MyRunnable();
>       Thread thread = new Thread(instance);
>       thread.start();
>   }
>   ```



> - 实现Callable接口（可以有返回值，返回值通过`FutureTask`进行封装）
>
> ```java
> public class MyCallable implements Callable<Integer> {
>     public Integer call() {
>         return 123;
>     }
> }
> 
> public static void main(String[] args) throws ExecutionException, InterruptedException {
>     MyCallable mc = new MyCallable();
>     FutureTask<Integer> ft = new FutureTask<>(mc);
>     Thread thread = new Thread(ft);
>     thread.start();
>     System.out.println(ft.get());
> }
> ```
>
> 
>
> - 继承Thread类（同样需要实现run()方法，因为Thread类也实现了Runnable接口）
>
>   **Thread是抽象类**！！



## 二、基础线程机制

> Executor（管理多个异步线程）
>
> ```java
> public static void main(String[] args) {
>     ExecutorService executorService = Executors.newCachedThreadPool();
>     for (int i = 0; i < 5; i++) {
>         executorService.execute(new MyRunnable());
>     }
>     executorService.shutdown();
> }
> ```
>
> 
>
> Daemon 
>
> ```java
> thread.setDaemon(true);//设置守护线程
> ```
>
> sleep
>
> yield



## 三、中断

> 线程如果在运行过程中发生异常也会提前结束
>
> ### Interrupted Exception
>
> > 通过调用一个线程的`interrupt()`来中断该线程，如果该线程处于阻塞、期限等待（sleep?）或者无限期等待状态，抛出`InterruptedExeception`,从而提前结束进程，但是不能中断I/O阻塞和`synchronized`锁阻塞
> >
> > `example`:
> >
> > ```java
> > public class InterruptExample {
> > 
> >     private static class MyThread1 extends Thread {
> >         @Override
> >         public void run() {
> >             try {
> >                 Thread.sleep(2000);
> >                 System.out.println("Thread run");
> >             } catch (InterruptedException e) {
> >                 e.printStackTrace();
> >             }
> >         }
> >     }
> > }
> > 
> > public static void main(String[] args) throws InterruptedException {
> >     Thread thread1 = new MyThread1();
> >     thread1.start();
> >     thread1.interrupt();
> >     System.out.println("Main run");
> > }
> > ```
>
> ### interrupted()
>
> > 如果一个线程的run()方法执行一个无限循环，并且没有执行`sleep()`等会抛出`InterruptedExeception`的操作，因此无法调用线程的interrupt()方法，但是调用其可以设置线程的中断标记：调用**`interrupted()`** 方法返回true，可提前结束线程。
> >
> > example:
> >
> > ```java
> > public class InterruptExample {
> > 
> >     private static class MyThread2 extends Thread {
> >         @Override
> >         public void run() {
> >             while (!interrupted()) {
> >                 // ..
> >             }
> >             System.out.println("Thread end");
> >         }
> >     }
> > }
> > 
> > public static void main(String[] args) throws InterruptedException {
> >     Thread thread2 = new MyThread2();
> >     thread2.start();
> >     thread2.interrupt();
> > }
> > ```
> >
> > ### Executer 的中断操作
> >
> > > `shutdown()`
> > >
> > > 只中断一个线程:(Lambda创建线程，相当于创建一个匿名线程)
> > >
> > > ```java
> > > Future<?> future = executorService.submit(() -> {
> > >     // ..
> > > });
> > > future.cancel(true);
> > > ```



## 四、同步和互斥

> ### `synchronized`(基于`JVM`)
>
> > ```java
> > public void func() {
> >  synchronized (this) {
> >      // ...
> >  }
> > }
> > ```
> >
> > ```java
> > public static void main(String[] args) {
> >  SynchronizedExample e1 = new SynchronizedExample();
> >  ExecutorService executorService = Executors.newCachedThreadPool();
> >  executorService.execute(() -> e1.func1());
> >  executorService.execute(() -> e1.func1());
> > }
> > ```
> >
> > - 同步代码块：同一个对象调用相同代码块
> > - 同步方法：同一个对象调用方法
> >
> > 
> >
> > - 同步类：同一个类不同对象调用相同代码块时会同步
> > - 同步一个静态方法：作用于整个类
>
> ### `ReentrantLock`(基于`JDK`)
>
> > `java.util.concurrent`(`J.U.C`)包中的锁
> >
> > ```java
> > public class LockExample {
> > 
> >     private Lock lock = new ReentrantLock();
> > 
> >     public void func() {
> >         lock.lock();
> >         try {
> >             for (int i = 0; i < 10; i++) {
> >                 System.out.print(i + " ");
> >             }
> >         } finally {
> >             lock.unlock(); // 确保释放锁，从而避免发生死锁。
> >         }
> >     }
> > }
> > ```



## 五、线程之间的协作

> ### `join`
>
> > 挂起当前线程，等待其他线程执行完成
>
> ### `wait` `notify` `notifyAll`
>
> > 不属于Thread，属于Object，只能在同步方法和同步控制块中使用，否则会抛出`IlleagalMonitorStateExeception`
> >
> > ```java
> > public class WaitNotifyExample {
> > 
> >     public synchronized void before() {
> >         System.out.println("before");
> >         notifyAll();
> >     }
> > 
> >     public synchronized void after() {
> >         try {
> >             wait();
> >         } catch (InterruptedException e) {
> >             e.printStackTrace();
> >         }
> >         System.out.println("after");
> >     }
> > }
> > ```
> >
> > 
>
> ### `await` `signal` `signalAll`
>
> > 基于`J.U.C`
> >
> > ```java
> > public class AwaitSignalExample {
> > 
> >     private Lock lock = new ReentrantLock();
> >     private Condition condition = lock.newCondition();
> > 
> >     public void before() {
> >         lock.lock();
> >         try {
> >             System.out.println("before");
> >             condition.signalAll();
> >         } finally {
> >             lock.unlock();
> >         }
> >     }
> > 
> >     public void after() {
> >         lock.lock();
> >         try {
> >             condition.await();
> >             System.out.println("after");
> >         } catch (InterruptedException e) {
> >             e.printStackTrace();
> >         } finally {
> >             lock.unlock();
> >         }
> >     }
> > }
> > ```
> >
> > 

