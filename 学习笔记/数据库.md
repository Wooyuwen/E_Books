# 数据库



## SQL语法

> 插入insert into table values (,,);
>
> 删除 delete from table where/null ;



## 事务

> 满足ACID特性的一组操作，commit提交事务，或者rollback进行回滚
>
> A(Atomicity)：原子性，事务所有操作要么全部提交成功，要么全部失败回滚，回滚可查看混滚日志(Undo Log)来实现，其记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
>
> C(Consistency)：执行前后都保持一致性状态，所有事务读取结果相同。
>
> I(Isolation)：一个事务所做的修改在最终提交前，对其他事务是不可见的。
>
> D(Durability)：一旦事务提交，所作修改会永远保存在数据库中，即使系统发生崩溃，事务执行的结果也不能丢失。如若系统奔溃，可以用重做日志(Redo Log)进行修复，从而实现持久性。其为对数据页的物理修改。



### 并发一致性问题

> 丢失修改
>
> 读脏数据
>
> 不可重复读
>
> 幻影读
>
> 原因：没有完全实现隔离性



### 封锁

> MySQL：两种封锁粒度：**行级锁**和**表级锁**
>
> 封锁粒度越小，系统开销越大
>
> 封锁粒度越小，系统并发度越高
>
> ##### 封锁类型：
>
> > 1读写锁：互斥锁X写锁、共享锁S读锁
> >
> > 2意向锁：更容易地支持多粒度封锁，相比读写锁增加了IX/IS表锁
>
> ##### 封锁协议：
>
> > 1三级封锁协议
> >
> > - 一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 `T 结束`才释放锁。--解决修改丢失问题
> >
> > - 二级封锁协议：在一级基础上，要求读取数据 A 时必须加 S 锁，`读取完`马上释放 S 锁 。 --解决读脏数据的问题
> >
> > - 三级封锁协议：前两级基础上，要求读取数据 A 时必须加 S 锁，直到`事务结束`才能释放 S 锁。        
> >
> >   --解决不可重复读问题
> >
> > 2 两段锁协议
> >
> > - 加锁和解锁分两个阶段进行
> >
> > -  可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。
> > - 事务遵循两段锁协议是保证可串行化调度的充分条件。
>
> ##### MySQL隐式与显式锁定
>
> > InnoDB采用两段锁协议，所有锁在同一时刻释放，隐式锁定



### 隔离级别

>未提交读：事务中的修改，即使没有提交，对其他事务也可见
>
>提交读：只能读提交的修改，隔离性
>



## 行列式存储



### 行式存储

> 适用场景：
>
> - 随机的增删改查
> - 在行中选取所有属性的查询操作
> - 频繁插入或更新的操作，其操作与索引和行的大小更相关
>
> 劣势：读取目标涉及少数几项属性，但是需要读取一条完整的行记录----加索引，表分区。



###　列式存储

> 数据仓库和分布式数据库：从各个数据源汇总数据进行分析和反馈，大多围绕同一列数据进行
>
> 列式数据库可以在内存中高效组装各列的值，最终形成关系记录集，因此可以显著减少IO消耗。
>
> 适用场景：
>
> - 查询过程中，可以针对各列的运算并发执行(SMP)，最后在内存中聚合完整记录集，最大可能降低查询相应时间。
> - 可在数据列中高效查找数据，无需维护索引(任何列都能作为索引)，查询过程中能够尽量减少无关IO
> - 各列独立存储，数据类型已知，可以针对该列的数据类型、数据量大小等因素动态选择压缩算法。
>
> 不适用场景：
>
> - 数据需要频繁更新的交易场景
> - 表中列属性较少的小量数据库场景
> - 不适合做含有删除和更新的实时操作



### Mysql表分区

> 分区：将一个表或索引分解为多个更小、更可管理的部分。
>
> Mysql分区类型为水平分区，表存储在多个物理分区（最多1024）



## Redis

> 
