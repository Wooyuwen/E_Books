# C++知识点



## 常见数据结构使用方法

> ![image-20211126144857818](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211126144857818.png)
>
 ### set
>
> ```cpp
> begin();            // 返回指向第一个元素的迭代器
> end();              // 返回指向迭代器的最末尾处（即最后一个元素的下一个位置）
> clear();            // 清除所有元素
> count();            // 返回某个值元素的个数
> 
> empty();            // 如果集合为空，返回true
> 
> equal_range();      //返回集合中与给定值相等的上下限的两个迭代器
> 
> erase()–删除集合中的元素
> 
> find()–返回一个指向被查找到元素的迭代器
> 
> get_allocator()–返回集合的分配器
> 
> insert()–在集合中插入元素
> 
> lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器
> 
> key_comp()–返回一个用于元素间值比较的函数
> 
> max_size()–返回集合能容纳的元素的最大限值
> 
> rbegin()–返回指向集合中最后一个元素的反向迭代器
> 
> rend()–返回指向集合中第一个元素的反向迭代器
> 
> size()–集合中元素的数目
> 
> swap()–交换两个集合变量
> 
> upper_bound()–返回大于某个值元素的迭代器
> 
> value_comp()–返回一个用于比较元素间的值的函数
> ```
>



### map

```cpp
begin()         返回指向map头部的迭代器

 clear(）        删除所有元素

 count()         返回指定元素出现的次数, (帮助评论区理解： 因为key值不会重复，所以只能是1 or 0)

 empty()         如果map为空则返回true

 end()           返回指向map末尾的迭代器

 equal_range()   返回特殊条目的迭代器对

 erase()         删除一个元素

 find()          查找一个元素

 get_allocator() 返回map的配置器

 insert()        插入元素

 key_comp()      返回比较元素key的函数

 lower_bound()   返回键值>=给定元素的第一个位置

 max_size()      返回可以容纳的最大元素个数

 rbegin()        返回一个指向map尾部的逆向迭代器

 rend()          返回一个指向map头部的逆向迭代器

 size()          返回map中元素的个数

 swap()           交换两个map

 upper_bound()    返回键值>给定元素的第一个位置

 value_comp()     返回比较元素value的函数
```



#### priority_queue

```cpp
priority_queue<int,vector<int>,greater<int>> heap
//自定义排序方式cmp可替换上面的greater<int>
    struct cmp{
        bool operator()(const **, const **){
            //logic
        }
    }
```



## 关键字



#### const

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

没有常量引用



#### 宏定义

![image-20211127155155993](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211127155155993.png)

#### static

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。



#### this

1. `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。

2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。

3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。

4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；

5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。

6. 在以下场景中，经常需要显式引用this指针：
   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 `list`。



#### inline

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。



**虚内联函数**

- 虚函数可以是内联函数，内联是可以修饰虚函数的

- **虚函数表现多态性的时候不能内联**

  内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。

- `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。



**编译器处理内联函数的步骤**

1. 将 `inline` 函数体复制到 `inline` 函数调用点处；
2. 为所用 `inline` 函数中的局部变量分配内存空间；
3. 将 `inline` 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 `inline` 函数有多个返回点，将其转变为 `inline` 函数代码块末尾的分支（使用 GOTO）。



**内联函数的优缺点**

优点：省去了参数压栈、栈帧开辟和回收、结果返回

​			相对于宏会做安全检查或者自动类型转换

​			内联函数可以在运行时调试

缺点：代码膨胀、无法随着函数库升级需要重新编译、**是否内联由编译器决定**



#### volatile

- `const`和指针都可以是volatile



#### 位域

类可以将非静态的数据成员定义为位域(bit-field)，在一个位域中含有一定数量的二进制位，当一个程序需要想其他程序或者硬件设备传递二进制数据时，通常会用到位域



#### extern "C"

- 被 extern 限定的函数或变量是 extern 类型的
- 被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的



#### explicit

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外



#### decltype

 用于检查实体的声明类型或表达式的类型及值分类



#### 左右值引用

右值引用：必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般标识对象的值

可实现转移语义和精确传递

- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。



## 面向对象



### 多态

1. 重载多态（编译期）：函数重载、运算符重载
2. **子类型多态**（运行期）：虚函数
3. 参数多态性（编译期）：类模板、函数模板
4. 强制多态（编译期/运行期）：基本类型转换、自定义类型转换



**静态多态**

函数重载



**动态多态**

-  虚函数: `virtual`修饰成员函数
- 动态绑定:使用基类的引用或指针调用一个虚函数

构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）



#### 虚函数

**虚函数带来的好处**: 可以定义一个基类的指针, 其指向一个继承类, 当通过基类的指针去调用函数时, 可以在**运行时**决定该调用基类的函数还是继承类的函数. 虚函数是实现多态(动态绑定)/接口函数的基础



#### 虚析构函数

**虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的**.

（1）**如果父类的析构函数不加virtual关键字** 
当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。 
（2）**如果父类的析构函数加virtual关键字** 
当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。 



#### 纯虚函数

没有实现,类似java中的接口

- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- 带纯虚函数的类叫**抽象类**，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
- **虚基类**是虚继承中的基类，具体见下文虚继承



#### 虚函数表

[介绍链接](https://blog.twofei.com/496/)

- 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
- 虚函数表：在程序只读数据段（`.rodata section`，见：[目标文件存储结构](https://github.com/huihut/interview#目标文件存储结构)），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。

![image-20211127213554553](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211127213554553.png)

为什么类对象空间中存指针不存指针数组:无法轻易修改数组



**同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针`__vfptr`(定义为`void**`类型)指向该虚函数表.**

- 她是编译器在**编译时期**为我们创建好的, 只存在一份
- 定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表



**几种继承情况**



继承类无重写只有成员

![image-20211127215133216](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211127215133216.png)



继承类重写父类中的虚函数

![image-20211127215116235](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211127215116235.png)



定义了基类没有的虚函数的单继承类

![image-20211127220049146](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211127220049146.png)



多继承且存在虚函数覆盖同时又存在滋生定义的虚函数

**保存到第1个拥有虚函数表的那个基类的后面的**



第一个直接基类没有虚函数

![image-20211127220417699](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211127220417699.png)

谁有虚函数表,谁放在前面



两个基类都没有虚函数:子类存虚函数表指针

![image-20211127220550477](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211127220550477.png)



#### 虚继承

解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）

```cpp
class A

class B1:public virtual A;

class B2:public virtual A;

class D:public B1,public B2;
```





#### 抽象类\接口类\聚合类

- 抽象类：含有纯虚函数的类
- 接口类：仅含有纯虚函数的抽象类
- 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
  - 所有成员都是 public
  - 没有定义任何构造函数
  - 没有类内初始化
  - 没有基类，也没有 virtual 函数