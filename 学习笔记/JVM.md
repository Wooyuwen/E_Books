## JVM



### HotSpot虚拟机

> ##### 对象内存布局分为：
>
> > - 对象头
> > - 实例数据
> > - 对齐填充8字节对齐
>
> ##### 对象创建过程
>
> > 类加载检查
> >
> > > JVM解析.class文件时，若遇到一条new指令，首先会去检查常量池中是否有这个类的符号引用，并检查这个符号所代表的类是否以已经被加载、解析和初始化过。如果没有，那么必须执行相应的类加载过程。
> >
> > 为新生对象分配内存
> >
> > > 对象所需的内存的大小在类加载完成后便可以确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中内存有两种方式：
> > >
> > > - 指针碰撞 ： 堆中内存绝对规整，复制算法和标记整理法。
> > > - 空闲列表：内存不规整，如标记清楚法
>
> ##### 对象访问方法：(HotSpot采用直接访问)
>
> > 句柄访问：堆中”句柄池“，句柄包含了对象实例数据（堆中的实例池）与类型数据（方法区）各自的具体地址信息。
> >
> > 直接访问：引用类型的变量直接存放对象的地址，但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址



### JIT

> Java：一次编译处处运行：javac编译形成字节码--解释器逐条将字节码`解释`为机器码
>
> 编译器将热点代码（字节码）编译成机器码
>
> 何为热点代码：JVM中设置阈值
>
> ![image-20211117124208523](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211117124208523.png)
>
> JVM中两种编译器：
>
> **client  compiler**：启动速度快，性能偏差
>
> **server compiler**：注重编译耗时较长的全局优化，启动时间长，适合长时间运行的后台程序



### AOT

> 在程序运行前生成Java方法的本地代码，以便程序运行时直接使用本地代码
>
> 但是对反射等运行时特性无法检测
>
> 存在目的：避免JIT编译器运行时性能消耗或内存消耗，避免解释程序的早期性能消耗



### 类的加载过程

> 类加载的三种方式：
>
> > 1 命令行启动应用时候由JVM初始化加载
> >
> > 2 通过Class.forName()方法动态加载，默认执行初始化块
> >
> > 3 通过ClassLoader.loadClass()方法动态加载，不会执行初始化块，如果指定loader，不执行静态块
>
> #### 加载 (Loading) ：
>
> 通过类的全限定名(包名+类名)，获取该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构转化为方法区运行时的数据结构，在内存中生成`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口：`加载二进制数据到内存` —> `映射成jvm能识别的结构` —> `在内存中生成class对象`。
>
> 
>
> #### 链接 (Linking) :
>
> 验证(检查class文件类型是否符合虚拟机标准)
>
> 准备(静态字段分配内存，并设置默认的初始值，一般为0/null，final类型在编译时就已经分配)
>
> 解析(符号引用转化为直接引用)(非必须)
>
> 
>
> #### 初始化 (Intialization) ：
>
> 为类的静态变量赋予正确的初始值，JVM负责对类进行初始化。
>
> > - 声明类变量是指定初始值
> > - 使用静态代码块为类变量指定初始值
>
> 若未加载需要先加载
>
> 执行类的构造器方法init()的过程
>
> 不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。
>
> 初始化顺序：
>
> 1. 父类（静态变量、静态语句块）
> 2. 子类（静态变量、静态语句块）
> 3. 父类（实例变量、普通语句块）
> 4. 父类（构造函数）
> 5. 子类（实例变量、普通语句块）
> 6. 子类（构造函数
>
> 
>
> > 五种常见的主动引用：
> >
> > - new 、putstatic 、getstatic 、invokestatic 字节码指令。 
> > - 反射调用。
> > - 初始化该类时需要先初始化其父类。
> > - 访问某个类或者接口的静态变量，或者对该静态变量赋值
> > - 虚拟机启动时，用于需要指定一个包含main()方法的主类、虚拟机会先初始化这个主类。
> > - 使用 JDK1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle 实例最后解析为 REF_getstatic/putstatic/invokestatic 的方法句柄，并且这个方法句柄所对应的类还没有初始化，需要先触发其初始化。
> >
> > 三种被动引用(类不会被初始化)：
> >
> > - 调用父类的类变量
> > - 数组类的初始化
> > - 类静态常量调用public static final
>
> 另外还包括：使用(非必须)和卸载过程。
>
> 三种加载器:
>
> > Bootstrap ClassLoader：<JAVA_HOME>/lib。(c/c++)
> >
> > Extension ClassLoader：<JAVA_HOME>/lib/ext。
> >
> > Application ClassLoader：负责加载用户类路径(classpath)上指定的库。
> >
> > Custom ClassLoader 此外还有用户定义的类加载器。
> >
> > 关系：向上委托



### 双亲委派机制

> 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。------------------系统类防止内存中出现多份同样的字节码
>
> 如果父类都没有加载，则会递归回来，尝试自己去加载class
>
> **父子关系是组合**
>
> **启动类加载器**(BootstrapClassLoader)：加载java核心类库
>
> **标准扩展类加载器**(ExtClassLoader)：加载扩展库，可直接使用
>
> **系统类加载器**(AppClassLoader)：加载程序所在目录的class
>
> **CustomClassLoader**（用户自定义类加载器）：加载指定路径的class文件
>
> 怎么打破：自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法。



### 本地内存

JVM 内存只是进程空间的一部分，除此之外进程空间内还有代码段、数据段、内存映射区、内核空间等

![image-20211122165405083](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211122165405083.png)

HeapbyteBuffer：本地内存缓冲的副本，JVM不会对其GC

DirectByteBuffer：存本地内存缓冲中的地址



### JVM内存结构



> 方法区：一种概念，有具体的实现形式，如HotSpot的永久代，**存储已被虚拟机加载的类信息：**
>
> - 字段（字段集合）
> - 方法（方法集合）
> - 常量池：final、字符串（class文件中的常量池除这些还有符号引用）
> - 构造函数字节码
> - JIT编译代码
>
> 
>
> **方法区 = 运行时常量池 + class文件信息（包含class文件常量池）**
>
> ![image-20211122163519342](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211122163519342.png)
>
> 常量池：
>
> > **静态常量池**(class文件中的常量池)：存字符串、final值以及类方法字段信息
> >
> > **运行时常量池**：类或接口加载后创建，包含编译器确定的数值字面量或者运行期解析后获得的方法或者字段引用（真实地址），可以在运行期间动态加入新的常量`String.intern()`

 

### 对象内存布局
> ![image-20211115181655817](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211115181655817.png)
> **对象头**：
>
> > - hashcode
> > - GC分代年龄
> > - 锁状态标志 01 01 00 10 11
> > - 线程持有的锁
> > - 偏向线程ID
> > - 偏向时间戳
> >
> > MarkWord主要用来表示对象的线程锁状态，还可配合GC并存放对象的hashcode
> >
> > 常见有五种不同状态：
> >
> > `lock`：锁状态标记位
> >
> > > - 正常01： biased_lock:0 hashCode
> > >
> > > - 偏向锁01： biased_loc:k1 偏向线程ID 偏向时间戳
> > >
> > > - 轻量级锁00：62位指针指向线程栈帧中的所记录
> > >
> > > - 重量级锁10：62位指针指向关联的监视器对象
> > >
> > >   Monitor：采用集合的形式来登记和管理排队的线程
> > >
> > > - GC标记11
> > >
> > > `biased_lock`：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。lock和biased_lock共同表示对象处于什么锁状态。
> > >
> > > `age`：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。
> > >
> > > `identity_hashcode`：31位的对象标识`hashCode`，采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。当对象加锁后（偏向、轻量级、重量级），MarkWord的字节没有足够的空间保存hashCode，因此该值会移动到管程Monitor中。
> > >
> > > `thread`：持有偏向锁的线程ID。
> > >
> > > `epoch`：偏向锁的时间戳。
> > >
> > > `ptr_to_lock_record`：轻量级锁状态下，指向栈中锁记录的指针。
> > >
> > > `ptr_to_heavyweight_monitor`：重量级锁状态下，指向对象监视器Monitor的指针。
> >
> > 
> >
> > 对象还可能包含类型指针(Klass Word指向方法区中class信息的指针)，通过该指针能确定对象属于哪个类，如果对象是数组可能还会包含数组长度
>
> 
>
> **实例数据**：成员变量的值，包括父类成员变量和本类成员变量
>
> **对齐填充**：用于确保对象的总长度为8字节的整数倍



### 类文件结构

> Class文件又称字节码文件，二进制文件
>
> **以8位字节为基础单位的二进制流**中间无分隔符
>
> ![image-20211122135806757](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211122135806757.png)
>
> 
>
> **1总体结构**：无符号数和表
>
> - 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值
> - 表：多个无符号数或者其他表作为数据项构成的复合数据类型
>
> **2魔数**：每一个Class文件的头4个字节成为魔数（Magic Number），**它的唯一作用是确定这个文件是否是一个能被虚拟机接收的Class文件**。
>
> **3版本号**：魔术后4字节，次版本号+主版本号
>
> **4常量池**：索引从1开始，主要存放**字面量**和**符号引用**
>
> - **字面量**：文本字符、final常量
> - **符号引用**：（需要在类创建或者运行时解析、翻译到具体的内存地址）
>   - 类和接口的全限定名
>   - 字段的名称和描述符
>   - 方法的名称和描述符
>
> **5访问标志**：u2，标识类或者接口层次的访问信息：Class是类还是接口、是否定义为public、是否定义为abstract类型、类是否被声明为final/abstract等
>
> **6类索引、父类索引、接口索引集合**：确定类的继承关系
>
> **7字段表集合**：成员变量（不含局部变量）
>
> **8方法表集合**：成员方法，结构类似于字段表
>
> **9属性表集合**
>
> ![image-20211122133723383](C:\Users\wywfd\AppData\Roaming\Typora\typora-user-images\image-20211122133723383.png)
>
> **验证**：虚拟机的语言无关性需要避免有害的类文件载入虚拟机中
>
> 




### JVM参数

> - 堆栈配置
>
> -Xmx:最大堆
>
> -Xms:堆初始大小
>
> -Xmn:年轻代大小
>
> -Xss:每个线程堆栈大小
>
> -XX:NewRatio=4：设置年轻代和老年代比值
>
> -XX:SurvivorRatio=4:设置年轻代Eden区与Survivor区的大小比值
>
> -XX：MaxTenuringThreshold=0:设置垃圾最大年龄，设置为0直接进入老年代



#### JVM dump

> 1 dump jvm内存: 
>
> ​	jmap -dump:format=b.file=dump_file_name pid
>
> 2 dump jvm线程栈:
>
> ​	jstack pid > dump_file_name
>
> 3 jstat 输出java程序内存使用情况
>
> ​	jstat -gcutil 27019 2000 5
>
> top -p pid：查看该服务的内存和cpu使用情况



#### 元空间和永久代

> 为什么要用元空间Metaspace取代永久代：
>
> - 字符串存在永久代中，容易出现性能问题和内存溢出
> - 类及方法的信息比较难确定大小，大了老年代溢出，小了永久代溢出
> - 永久代对GC带来不必要的复杂度，并且回收效率较低
>
> 元空间分配在本地内存，存放类的元数据
>
> 字符串常量池和java静态变量存放在堆中
>
> safe-point：在代码执行过程中的一些特殊位置，需要暂停时应当运行到安全点暂停



### GC

> 对象进入老年代的四种方式：
>
> - minor gc后，survivor区空间不能容纳全部存活对象
> - 存活对象达到年龄阈值。比如15（markword）
> - 大对象：**-XX:PretenureSizeThreshold=**大小
> - 动态年龄判断
>
> 
