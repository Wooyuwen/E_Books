# 数据库



## SQL语法

> 插入insert into table values (,,);
>
> 删除 delete from table where/null ;



## 事务

> 满足ACID特性的一组操作，commit提交事务，或者rollback进行回滚
>
> A(Atomicity)：原子性，事务所有操作要么全部提交成功，要么全部失败回滚，回滚可查看混滚日志(Undo Log)来实现，其记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
>
> C(Consistency)：执行前后都保持一致性状态，所有事务读取结果相同。
>
> I(Isolation)：一个事务所做的修改在最终提交前，对其他事务是不可见的。
>
> D(Durability)：一旦事务提交，所作修改会永远保存在数据库中，即使系统发生崩溃，事务执行的结果也不能丢失。如若系统奔溃，可以用重做日志(Redo Log)进行修复，从而实现持久性。其为对数据页的物理修改。



### 并发一致性问题

> 丢失修改
>
> 读脏数据
>
> 不可重复读
>
> 幻影读
>
> 原因：没有完全实现隔离性



### 封锁

> MySQL：两种封锁粒度：**行级锁**和**表级锁**
>
> 封锁粒度越小，系统开销越大
>
> 封锁粒度越小，系统并发度越高
>
> ##### 封锁类型：
>
> > 1读写锁：互斥锁X写锁、共享锁S读锁
> >
> > 2意向锁：更容易地支持多粒度封锁，相比读写锁增加了IX/IS表锁
>
> ##### 封锁协议：
>
> > 1三级封锁协议
> >
> > - 一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 `T 结束`才释放锁。--解决修改丢失问题
> >
> > - 二级封锁协议：在一级基础上，要求读取数据 A 时必须加 S 锁，`读取完`马上释放 S 锁 。 --解决读脏数据的问题
> >
> > - 三级封锁协议：前两级基础上，要求读取数据 A 时必须加 S 锁，直到`事务结束`才能释放 S 锁。        
> >
> >   --解决不可重复读问题
> >
> > 2 两段锁协议
> >
> > - 加锁和解锁分两个阶段进行
> >
> > -  可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。
> > - 事务遵循两段锁协议是保证可串行化调度的充分条件。
>
> ##### MySQL隐式与显式锁定
>
> > InnoDB采用两段锁协议，所有锁在同一时刻释放，隐式锁定



### 隔离级别

>未提交读：事务中的修改，即使没有提交，对其他事务也可见
>
>提交读：只能读提交的修改，隔离性
>
>

