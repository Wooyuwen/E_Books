#### RISC:（ 精简指令集计算机）体系结构（MIPS：采用精简指令集的指令集架构ISA）

- 所有数据操作都是对寄存器中数据的操作们通常会改变整个寄存器

- 只有装入和存储会影响存储器，他们分别将数据从存储器移到寄存器或者从寄存器移到存储器。

  通常存在一些可以载入或存储低于一个完整寄存器的内容

- 指令格式的数量很少，所有指令都是同一种大小

寄存器0的值总为0

MIPS通常有三种指令

> - ALU指令：两个寄存器或者一个寄存器加上一个符号扩展立即数，将结果存于第三个寄存器中
> - 载入和装入指令：这些指令获取一个寄存器源（基址寄存器）和一个立即数字段为操作数，将二者之和作为存储器地址。载入`LD`和存储`SD`。
> - 分支和跳转指令：指控制的条件转移

存储指令4个周期；分支指令2个周期；其他指令5个周期



### 流水线技术特点

> - 把一个处理过程分解为若干个子过程 ，每个子过程由一个专门的功能部件来实现
> - 各段时间应尽可能相等，否则：阻塞/断流
> - 每个功能部件后面有一个缓冲寄存器（锁存器）：流水寄存器

**通过时间**：第一个任务从进入流水线到流出结果所需的时间

**排空时间**：最后一个任务从进入流水线到流出结果所需要的时间



`单功能流水线`：只能完成一种固定功能的流水线

`多功能流水线`：各段可以进行不同的连接

`动态流水线`：同一时间内，多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能

`非线性流水线`：有回路

`乱序流水线`：任务流入流出的顺序不同

### 流水线的性能指标

> ##### 吞吐率：
>
> 单位时间内流水线所完成的任务数量或输出结果的数量
>
> ​    `TP=n/Tk`
>
> `n`:任务数    `Tk`:处理完成n个任务所用的时间
>
> 解决瓶颈：细分，将3变为3个1、设置重复瓶颈段
>
> ##### 加速比：
>
> 完成同一批任务，不使用流水线所用的时间与使用流水线所用的时间之比
>
> ##### 假设：
>
> >  不使用流水线（即顺序执行）所用的时间为`Ts`，使用流水线后所用的时间为`Tk`，则该流水线的加速比为`S=Ts/Tk`。
>
> ##### 效率：
>
> > 流水线中的设备实际使用时间与整个运行时间的比值，即流水线设备的利用率
> >
> > 各段效率`en` 整条流水线效率：`E=（e1+...ek）k`
>
> **流水线深度：** 非流水线时钟周期/流水线时钟周期

##### 五段流水线

> 取指令：`IF`
>
> 指令译码/读寄存器周期:` ID` （并行执行）
>
> - 译码
> - 用IR中的寄存器编号去访问通用寄存器组，读出所需的操作数。
> - 确定是否为分支，计算出分支目标地址
>
> 执行/有效地址计算周期`EX`：三种指令类型
>
> 存储器访问/分支完成周期 `MEM`：如果是载入，读取数据；存储，写入数据，所有指令都要在这更新PC值
>
> 写回周期 `WB`：`RR`,`R Im`,`load`
>

##### 流水线冒险

> **结构冒险**：因硬件资源满足不了重叠执行的要求而出现资源冲突，导致结构冒险（功能部件不是完全流水、资源份数不够）
>
> > `插入暂停周期`    、   设置相互独立的指令存储器和数据存储器或者设置相互独立的指令cache和数据cache
> >
> > 有时流水线设计者允许结构冒险的存在：节省硬件成本，如果重复设置足够份数，花费成本较高
>
> **数据冒险**：需要用到前面指令的执行结果，导致数据冒险;
>
> > 当相关的指令靠的足够近，它们在流水线中的重叠执行或者重新排序会改变指令读/写操作数的顺序，使之不同于它们非流水实现时的顺序
> >
> > - 转发技术减少数据冒险引起的停顿（旁路或短路技术）
> >
> > ​      在某条指令产生计算结果之前，其他指令并不真正需要该计算结果，将产生结果送到其他指令需要该节该结果的地方——`ALU-ALU？`
> >
> > - 需要停顿的数据冒险：载入指令
> > - 增加流水线互锁硬件，插入“停顿”（或气泡`stall`）：检测发现数据冲突，并使流水线停顿，直至冲突消失
>
> **控制冒险**(分支冒险)：流水线遇到分支指令和其他会改变PC值得指令，导致控制冒险
>
> > - 分支成功：PC值改变为分支转移的目标地址。在MIPS流水线中，通常会在ID末尾，完成地址计算和条件判定后，才改变PC值
> > - 不成功：PC值不变，指向顺序的下一条指令
> >
> > 处理方式：冻结流水线：保留或删除分支之后的所有指令，直到分支目标地址
> >
> >   若预测分支失败：
> >
> > > - 允许分支指令后的指令继续在流水线中流动，就好像什么都没有发生
> > > - 将分支指令看作是一条普通指令，流水线正常流动
> > > - 若确定分支成功，流水线就把分支指令之后取出的所有指令转化为空操作，并按分支目标地址重新取指令执行
> >
> >  若预测成功：
> >
> > > - 假设分支转移成功，并从分支目标地址处取指令执行
> > > - 前提：先知道分支目标地址，后知道分支是否成功
> >
> > 
> >
> > ##### 延迟分支：
> >
> > > 把延迟分支看成是由原来的分支指令和若干个延迟槽构成（一般为1个），不管分支是否成功都要按顺序执行延迟槽中的指令
> >
> > 分支延迟指令的调度：
> >
> > > 任务：在延迟槽中放入有用的指令
> > >
> > > 由编译器完成：能否带来好处取决于编译器能否把有用的指令调度到延迟槽中
> > >
> > > 三种调度方法：
> > >
> > > - `从前调度`: 被调度的指令必须与分支无关  ---任何情况下都起作用
> > > - `从目标调度`：必须保证在分支失败时执行被调度的指令不会导致错误。有可能需要复制指令 --分支成功时起作用
> > > - `从失败处调度`：必须保证在分支成功时执行被调度的指令不会导致错误 ----分支失败时起作用



### 3 实现流水化

> `MIPS`的简单实现

