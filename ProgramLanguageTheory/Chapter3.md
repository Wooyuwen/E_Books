## 对象和环境



> 约束时间：建立联系，指一个联系的建立时间（有时还要考虑持续时间）。广义指做出一种决策的时间
>
> 连接时：静态数据对象分配、跨模块对象约束，库对象约束
>
> 装载时：静态对象的内存定位，虚地址到实地址的映射
>
> 运行时：自动变量的存储位置、变量的值约束，运行时的其他事项

> 数据：能在程序与外界间传送（输入、输出），在程序里保留保存/处理的信息
>
> 数据是程序运行中存在的，被动性的实体
>
> 为什么需要把数据分为类型：
>
> -  提供了对被处理数据的一种概念划分
> -  `more efficinet comlimentary`是对数据的使用加以控制盒检查



> #### 对象的生存期：
>
> > 创建：静态创建（编译时，连接时或者装载时）、动态创建（运行中创建）
> >
> > 销毁：运行中完成，有可能是资源的处理问题，程序终止时完成
>
> 
>
> **持续性对象**：生存期跨越程序运行期的对象
>
> **静态对象**：静态创建，直到程序终止时销毁
>
> **非静态对象**：程序运行中创建和销毁
>
> 
>
> **生存期：存储分配**
>
> > 对象分配：
> >
> > - 静态分配：确定对象的地址和范围，执行中保持不变
> > - 栈分配：具有后创建先销毁性质的对象，可以采用栈分配技术
> > - 堆分配：不能采用上述方式分配的对象
>
> 
>
> 存储区域：
>
> > 静态区（只读区：代码放在只读区、常量也可能被放在只读区，可读写区：静态分配的变量）
> >
> > 栈区（程序运行栈）
> >
> > 堆区（动态管理区）
>
> 
>
> **静态分配**：静态分配的对象，其所有性质必须能静态确定，常见：全局变量、需要建立对象的常量
>
> 
>
> **栈分配**：在允许递归的语言里，子程序里定义的局部对象不能静态分配
>
> > 运行进入一个子程序时，为这个子程序的帧在栈里分配空间
> >
> > 设置帧指针（通常用一个寄存器）指向当前子程序的帧
> >
> > 子程序里使用局部对象都通过帧指针按特定偏移量进行。利用CPU的位移寻址模式（`sp`,`fp`）
>
> **堆分配**：如果分配的对象有后创建先销毁的性质，就可以在运行栈里分配，否则只能在堆中分配
>
> > 堆支持任意顺序的分配和释放，最灵活（最容易出错）
> >
> > 自动释放技术：`
> >
> > 1 把堆对象约束于适当的栈对象，借助栈对象的销毁自动释放堆对象（`cpp`智能指针）
> >
> > 2 自动回收机制 `java GC`



###  对象:分类

> - 变量 ：有名字，用于保存值的对象。其值在生存期中可以变化
> - 常变量：有名字且有值。在创建时给定，生存期间不变(`const` )
>
> - 常量：如建立的字符串(`c`)
>
> - 匿名对象： (`new A().show()`)
>
>   > - 通过动态存储分配创建的匿名对象，通过指针或者引用使用
>   > - 保存中间结果的临时对象，如函数的返回对象，隐含使用
>
> - 子程序对象：通常为执行代码
>
> - 程序的内部对象（由具体的语言决定）(内部类？)
>
>   > - 为支持程序运行而创建的各种内部数据结构（运行栈、栈帧等）
>   > - 类型的运行时表示，等等





### 作用域

> 定义建立名字与事物之间的约束，这一约束在源程序中的作用范围称为这一约束的作用域(scope)，也说是这个定义或声明的作用域
>
> > 声明有确定的作用范围（作用域），只在确定范围里有效
> >
> > 在声明的作用域里，被声明名字指称相应的对象
>
> 
>
> 单位：一般以子程序（过程/函数）作为作用域单位，其他作用域单位：
>
> > - 结构/记录的声明，`OO`语言中的类定义
> > - 模块结构，(`cpp`的名字空间,`Ada`的包)
> > - C源文件
>
> `HINTS`：
>
> C语言的全局作用域可以定义/声明变量、函数、类型等。函数只允许定义在全局作用域里
>
> C语言的局部作用域时复合语句
>
> 
>
> **冲突和嵌套**：在一个作用域中同一个名字不能有多个约束：不同作用域的名字相互无关，内层定义“屏蔽”外层定义--应避免同名对象的作用域嵌套
>
> 名字冲突，一个名字具有多个约束的现象称为重载`overloading`
>
> 
>
> 可以存在多种作用域单位，允许单位进行嵌套
>
> 在一个语言中有可能对不同的程序结构采用不同的作用域规则
>
> 
>
> **静态作用域**：对非局部名字，其约束根据名字出现位置的静态正文环境决定
>
> **动态作用域**：非局部名的约束根据当时的动态运行环境确定
>
> `cpp`：类、继承形成的作用域嵌套、方法的作用域嵌套在类作用域中
>
> `java`：全局作用域中只能定义类（全局作用域中没有对象名）、类定义形成作用域、方法作用域嵌套在类作用域中、用`package`形成的模块作用域
>
> 一个定义/声明的作用域，常见的两种规定：
>
> > - 定义的作用域从定义出现的位置到当前作用域结束
> > - 定义的作用域包括整个当前作用域
>
> `标号`：标明代码中的一个位置，作为goto的目标
>
> **名字分类**：程序中有多种命名事物（命名对象、类型、结构的成分名、标号等等），有些语言对名字做了分类。同意作用域里属于不同类别的名字互不冲突
>
> C语言规定了三个名字类：
>
> > - 标号名
> > - `struct`/`union`/`enum`标志
> > - 变量名、函数名、类型名、typedef名、枚举常量名
> > - 此外每个结构或联合声明也是一个“名字空间”（包含其中的各成分名）
>
> #### 名字重载：
>
> > 重载：在同一作用域中，一个名字约束于多个对象
> >
> > 常见：算数运算符，“+”运算符表示多种加法运算
> >
> > 重载解析：
> >
> > > 静态解析：在编译时利用静态上下文信息确定名字的正确约束，主要利用类型信息，确定应该使用的定义
> > >
> > > 动态解析：利用动态的上下文信息。如`OO`语言的方法动态指派
>
> 程序对象通常都有约束值。根据可做的不同操作，值有如下分类：
>
> - 一级值：可以赋给`变量`、作为`参数`传入子程序、作为函数`返回值`的数据或对象，大部分程序中，简单类型（整数、字符等）的值都是一级值
> - 二级值：可以传入子程序。但不能返回也不能赋值，只能做参数
> - 三级值：不能传入子程序（除二级值的限制外）



### 对象和值

> 对象的值约束有两种基本方式：
>
> 1 值保存在对象的存储区中----------值语义（值模型）
>
> 2 对象的值是另一个对象，存储其他对象的引用------------引用语义（引用模型）
>
> ---`Tips: java中除基本类型的变量采用值语义，其他类型的变量都采用引用语义`



### 变量

> 变量是一种命名程序对象，作用是保存值，所保存的值可以在程序执行中改变（与值得约束可动态改变，一般是通过赋值操作）
>
> 常变量：其值在创建时给定，生存期间不变(`final`/`const`)
>
> 由于语言不同或者情况不同，变量的属性可能：
>
> > 1 关联于变量的标识（变量名），只是静态可用（静态属性）
> >
> > 2 关联于程序对象或者值（对象），是动态属性，在执行中可用
>
> 与变量名关联的程序对象是变量的运行时的实体体现
>
> 其他属性可能只是静态可用，或者动态也可用（例如C语言中的数组大小，只为分配空间用，一些语言支持动态越界检查）
>
> - 变量名与相应对象的约束是静态的
>
> - 对象与值的约束是动态的，可变
>
> ##### 初始化和赋值：
>
> 引用变量和引用参数：
>
> > 许多语言中的函数/过程可以有引用参数，例如 `int fun (int &n,..){...}`
> >
> > 没有对引用变量本身的操作，只能通过它去操作被引用的对象
> >
> > 引用参数（变量参数）就是在函数里为实参（必须是程序对象）建立一个局部的名字，通过这个名字可以直接访问实参对象（可能是个变量）（`cpp`中需要考虑`const`）
>
> **指针变量**：以变量（对象）标识为值的变量（由于常以变量的内存地址作为其标识，所以常说指针变量以“地址”为值），指针很像引用，但其本身也可操作。值语义的语言里用“指针”模拟引用语义，支持动态存储管理，建立复杂数据结构。
>
> **别名**：如果与一个对象约束的名字多于一个，程序正文中不同的名字实际引用着同一个对象。
>
> > ---`tips`别名使程序理解更加困难，人或系统（如编译器）更难推断程序的行为（难做分析和优化）也增加了为程序建立严格语义理论的难度。
> >
> > - 局部参数与全局变量称为别名
> >
> > - 不同的引用参数相互成为别名
>
> **悬空引用**：(`dangling reference`)：程序执行中的某个时刻，处于活动状态的指针变量没有引用到合法的对象
>
> > 危险性：从悬空引用出发间接读取，得到的是非法数据、对悬空引用间接赋值，可能造成无法预计的破坏
> >
> > 定义后没有初始化的指针变量也处于悬空状态，如C：
> >
> > - 全局指针自定设置为空，间接访问这种指针通常会引发操作系统异常
> > - 局部指针不自动初始化，处于非法状态，间接访问可能引发操作系统异常，或导致难检查的错误
> >
> > 一些设计：多数语言里没有取地址操作、禁止把生存期短的对象的地址赋给生存期长的指针，可以减少悬空引用
>
> **悬空引用和废料**：产生悬空引用的最大问题是复杂数据结构中的值共享：其中可能出现多个指针或者引用实际上关联于同一个对象的情况
>
> **产生废料的结果**是可能使长期运行的系统由于空间“耗尽”而被迫中止，可采用一些编程规则管理存储，但是仍为复杂系统实现中的巨大负担
>
> **废料**：丧失了引用途径，已经不能在程序里访问，但仍然占据着存储，没有释放的“死对象”
>
> 如果没有存储释放操作，悬空引用问题剩下：“空指针间接”，而“空指针”是明确的状态，可以在程序里检测（非空指针悬空无法检测）
>
> - `cpp`把堆对象关联于存在期明确的对象（栈对象），可自动执行析构函数释放动态分配的对象
>
> - 引用计数技术：运行时维护对每个堆对象的引用数，技术为0时释放
>
> #### ***  废料收集（`GC`） ***
>
> > 主要技术：
> >
> > > - 标记-清扫：通过引用关系标出空间中全部活对象，收集其余对象
> > > - 复制式：把活对象及其连接关系复制到另一存储区，原区全部收回
> > > - 分代式：复制式的改进，利用对象的生存特性（生命期预测）提高`GC`效率
> > >
> > > `cpp`设计者反对废料收集
> > >
> > > 处理器速度提高，内存扩大，废料收集的开销基本忽略
> > >
> > > 在系统开发中完美地管理存储，为程序员的必备技能
> > >
> > > `OO`的广泛应用，没有废料收集，开发`OO`程序的代价会大大提高（提供GC机制的语言:JAVA,C#）



变量值模型和引用模型总结

> - 值保存在变量的存储区里，实现简单，易使用，易理解
> - 变量的值实际用另一个值对象表示，实现复杂，需要复杂的存储管理技术的支持；概念的理解也比较困难
> - 值可以直接访问，效率高（因此被大多数常规语言采用）
> - 需要多做一次间接访问，效率有所降低
> - 赋值是值的拷贝，语义清晰，易于理解；但对于大对象可能费时
> - 赋值是引用共享，语义较复杂，编程要当心；只修改引用，效率高
> - 存储管理方便，可根据变量的作用域，利用栈机制统一进行管理，存储管理简单，管理开销小
> - 由于值对象的创建和销毁，复杂的相互引用关系，必须有堆存储管理的支持和废料收集，管理复杂，开销大
> - 需要静态确定变量类型，静态完成存储的分配或安排（如自动变量）。需要变量的类型声明和静态处理。带来高的执行效率；但难支持动态确定大小的数组和其他具有动态性质的数据结构，包括字符串等
> - **指针是比引用更难用的机制，是程序错误的重要根源**
> - 在值模型语言的实现里，对某些特殊数据对象，需要在内部采用引用模式实现，例如，动态数组/字符串。
> - 在引用模型语言的实现里，为了提高效率，基本类型（如各种数值）常采用值方式实现（只是为了提高效率，不是必须）

