## 基本控制抽象和子程序

> 数据抽象：抽象的对象是被操作数据概念和相关功能
>
> **控制抽象**：抽象的对象是实现某种功能的可能复杂的操作，定义和实现能良好执行的操作
>
> 
>
> `子程序是主要的计算过程抽象机制`
>
> 常见的子程序概念：
>
> - 过程：完成一系列动作的顺序子程序，具有典型的后进先出性质
> - 函数：一类过程，其执行的基本目的是算出一个值
> - `OO`语言里类的方法，是附着在类的实例对象上的子程序
>
> 协作子程序：允许同时存在多个正在执行中的协程，协程之间采用显式的挂起/唤醒方式转移控制权，每个时刻只有一个协程处于活动状态
>
> 并行子程序：可同时存在多个执行，由基础支持系统（调度器等）确定控制转移，一个时刻可能有多个并行的活动（进程）
>
> ##### 子程序抽象
>
> > 子程序实现一个局部的计算环境，是一种控制的封装和屏蔽机制
> >
> > - 局部环境具有私密性，与外围环境之间有清晰的划分
> > - 与外围环境之间有清晰的接口，课通过接口单向或双向传递信息
> >
> > 子程序定义一种作用域，通常是“单向透明”的（开作用域）：外部定义在内部可见，内部定义在子程序外不可见
> >
> > 过程和函数的后进先出性质，可以利用栈结构方便的管理子程序调用所需的内存，管理方便，效率高。
>
> ##### 子程序参数化
>
> > 想法来源：汇编语言的宏
> >
> > 参数化使子程序更加通用，实现参数化的方式就是把子程序性质中的某个部分抽取出来，建立反映了这一部分的变化的参数
> >
> > 参数化使同一段代码可以作用于不同的实际参数集合
> >
> > 实际程序设计对参数有许多不同的需要
>
> ##### 子程序的定义和执行
>
> > 子程序定义是一种语言结构，其最基本的部分是一个代码体，其中描述该子程序所需要执行的动作
> >
> > 有且只有一个定义
> >
> > 一个**接口描述**，本身不生成代码
> >
> > 最基本部分：**代码体**——>目标代码
> >
> > 实现子程序功能：实现子程序的调用和正确执行，还需要生成一些辅助性代码
> >
> > > - 前序代码：在子程序本身的代码执行前完成一些准备工作
> > > - 后序代码：结束前的清扫，为正确返回调用方而做一些的恢复工作
> >
> > 子程序的定义分为两个部分：
> >
> > 1描述子程序和外界关系的界面定义部分
> >
> > > - 子程序名字
> > > - 子程序参数
> > >   - 参数类型
> > >   - 信息传递方式（参数模式）
> > >   - 参数名（以便在子程序体里使用外界传来的信息）
> > >
> > > - 返回值
> >
> > 2描述子程序执行时的局部环境和动作实现部分
> >
> > > 子程序被调用时，需要为它建立一个活动，其中包括
> > >
> > > > - P的代码体（或当时代码执行情况的记录，即当前的代码执行位置）
> > >>
> > > > - 一个表征P的局部状态的数据结构，称为活动记录(activity record)
> > > >
> > > > 活动记录使根据P的局部数据做出的安排（布局），其中包括：
> > > >
> > > > > - P的所有参数和局部变量
> > > > > - 为支持子程序启动、执行和结束所需的各种辅助性数据结构
> > > >
> > > > P的每个调用启动时将建立一个新活动记录，该活动结束时销毁这个记录，这种活动记录也是数据对象（内部数据对象），因此有
> > > >
> > > > > 创建和销毁
> > > > >
> > > > > 在子程序运行过程中被使用和修改
> > > 
> > > 执行中可能同时存在P的多个不同活动（如有递归调用过程）：
> > >
> > > > 每个活动需要有一个独立的活动记录
> > >>
> > > > 多个活动可以共享P的同一代码段（常规语言里，代码是静态的，不必创建多个副本）
> > > >
> > > > 子程序P的一个具体活动的执行状态：
> > > >
> > > > > 代码体的当前执行位置（确定下一条要执行的指令）
> > > > >
> > > > > 当时活动记录的状态，主要是P的所有局部变量的取值情况
> > > > >
> > > > > 可能存在的尚未记录到内存（活动记录）里的寄存器状态
> > > 
> > > 为了支持程序的执行，需要两个指针：
> > >
> > > > - IP（指令指针）：指向将要执行的那条指令，并随着指令的执行而更新
> > >>
> > > > - EP（环境指针）指向当前子程序的当前活动记录
> > > >
> > > >   > 由他出发可以**确定**当前子程序中的所有数据引用
> > > >   >
> > > >   > 子程序代码体中大部分数据引用是基于该指针获得的
> > > >
> > > > 代码中的指令基于环境指针更新当前活动记录中的某些数据项（还可能修改静态环境和外围环境）从而实现程序执行中的状态改变
> > > >
> > > > 程序开始执行前建立主程序的活动记录（静态创建，如有主程序），令EP指向改记录，IP指向主程序代码段的起始位置，程序开始执行
> > > >
> > > > 在启动（调用）一个子程序时，需要
> > > >
> > > > > - 保存当前子程序活动记录和IP/EP，还需要保存一些有用的寄存器值（子程序恢复执行时还需要恢复和使用的值）
> > > > > - 为被调用的子程序创建一个新活动记录，设置IP/EP指针（转换环境，转换执行点），而后令控制转入被调用的子程序（按设置好的新IP执行），实现执行现场的转移
> > > >
> > > > 当需要转到一个以前暂停的子程序时，需要恢复原来保存的现场
> > > >
> > > > > - 保存当前子程序的状态（活动记录，有用的寄存器和IP/EP指针）
> > > > > - 恢复以前保存的寄存器值和IP/EP值
> > > > > - 按恢复后的IP值继续执行
> > > >
> > > > 函数/过程的抽象执行过程
> > > >
> > > > 子程序之家控制转移的最简单情况是过程/函数的调用/返回
> > > >
> > > > > - 调用时，控制转到被调子程序
> > > > > - 被调子程序结束时，控制转回到调用子程序
> > > >
> > > > 处于活动状态的子程序可能很多，在调用一个新子程序时，IP/EP保存在哪：
> > > >
> > > > > 过程和函数具有后进先出性质，将它们保存在被调子程序活动记录里的某个固定位置，子程序返回时可以方便的取出使用
> >
> > 
> >
> >  #### 静态模型
> >
> >  > 运行中任何时刻子程序（至多）只有一个活动记录，因此可以在执行前静态建立所有子程序的活动记录（都在静态区分配）
> > >
> > > 静态模型下的局部和全局数据都可以直接寻址，调用的辅助工作较少（可能需要保存一些寄存器，也可存入被调子程序的活动记录），实现效率高
> >
> > #### 调用返回的一般模型
> >
> > > 递归->多个活动对象->`IP/EP`对技术
> > >
> > > 如果调用后进先出,活动记录可用栈分配,称为栈帧,用帧指针`fp`作为`EP`
> > >
> > > - 程序运行中栈里保存着一些帧(子程序活动记录),每个帧里保存的ep/fp是栈里下一个子程序帧的地址,形成一条链(动态调用链/寄存器动态链)
> > > - 帧的分配释放表现为栈的压入和弹出
> > >
> > > **局部环境的栈实现**
> > >
> > > > 子程序P的运行环境主要通过P的栈帧实现,多数局部对象在P的帧里有一个存储位置(相对于帧指针的特定偏移量);局部变量访问都相对于指针`fp`进行
> >
> > 
> >
> > #### 调用序列
> >
> > > 编译器生成的代码段,完成子程序调用和退出时的运行栈维护
> >
> > 
> >
> > #### 异常检测
> >
> > 

